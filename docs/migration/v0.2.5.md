# Migration Guide: v0.2.5 - Effect Services

This guide helps you migrate to Fred v0.2.5, which introduces Effect-based services internally while maintaining backwards-compatible Promise APIs.

## Overview

v0.2.5 introduces:

- Internal Effect Services architecture for better resource management
- Optional Effect API via `fred/effect` for power users
- Vercel AI SDK-style streaming with rich result objects
- Tagged errors for type-safe error handling
- `Fred.create()` async factory for proper initialization

## Breaking Changes

### Fred Initialization

**Before (v0.1.x):**

```typescript
import { Fred } from 'fred';

const fred = new Fred();
await fred.registerDefaultProviders();
```

**After (v0.2.5 - recommended):**

```typescript
import { Fred } from 'fred';

const fred = await Fred.create();
await fred.registerDefaultProviders();
```

The constructor still works for backwards compatibility, but `Fred.create()` ensures proper Effect runtime initialization and is recommended for new code.

### Streaming Responses

**Before (v0.1.x):**

```typescript
const stream = fred.streamMessage('Hello');

for await (const event of stream) {
  if (event.type === 'text') {
    process.stdout.write(event.text);
  }
}
```

**After (v0.2.5):**

```typescript
const result = fred.streamMessage('Hello');

// Option 1: Simple text streaming
for await (const text of result.textStream) {
  process.stdout.write(text);
}

// Option 2: Full event streaming (closest to v0.1.x behavior)
for await (const event of result.fullStream) {
  // Process all event types
}

// Option 3: Await final result
const text = await result.text;
const usage = await result.usage;

// Option 4: Use callbacks
result.onChunk = (event) => console.log(event);
result.onFinish = ({ text, usage }) => console.log('Done:', text.length);
for await (const _ of result.fullStream) {}
```

### Error Types

**Before (v0.1.x):**

```typescript
try {
  const agent = fred.getAgent('nonexistent');
} catch (error) {
  if (error.message.includes('not found')) {
    // Handle not found
  }
}
```

**After (v0.2.5):**

```typescript
// Promise API: errors wrapped with cause
try {
  const agent = await fred.getAgent('nonexistent');
} catch (error) {
  // error.cause contains the original Effect error
  if (error.cause?._tag === 'AgentNotFoundError') {
    console.log('Agent not found:', error.cause.id);
  }
}

// Effect API: type-safe error handling
import { Effect } from 'effect';
import { AgentService, AgentNotFoundError } from 'fred/effect';

const program = Effect.gen(function* () {
  const agentService = yield* AgentService;
  return yield* agentService.getAgent('my-agent');
}).pipe(
  Effect.catchTag('AgentNotFoundError', (e) => {
    console.log(`Agent ${e.id} not found`);
    return Effect.succeed(fallbackAgent);
  })
);
```

## New Features

### Effect API (Optional)

For users who want full Effect composition, import from `fred/effect`:

```typescript
import { Effect, Layer } from 'effect';
import {
  FredLayers,
  AgentService,
  AgentNotFoundError,
} from 'fred/effect';

const program = Effect.gen(function* () {
  const agentService = yield* AgentService;
  const agent = yield* agentService.getAgent('my-agent');
  return agent;
}).pipe(
  Effect.catchTag('AgentNotFoundError', (e) => {
    console.log(`Agent ${e.id} not found`);
    return Effect.succeed(fallbackAgent);
  })
);

const result = await Effect.runPromise(
  program.pipe(Effect.provide(FredLayers))
);
```

### Tagged Errors

All errors now use Effect's `Data.TaggedError` for type-safe handling:

```typescript
import {
  // Agent errors
  AgentNotFoundError,
  AgentAlreadyExistsError,
  AgentCreationError,
  AgentExecutionError,

  // Pipeline errors
  PipelineNotFoundError,
  PipelineAlreadyExistsError,
  PipelineExecutionError,
  PipelineStepError,
  CheckpointNotFoundError,
  CheckpointExpiredError,
  PauseNotFoundError,
  PauseExpiredError,
  ConcurrencyError,
  GraphValidationError,

  // Tool errors
  ToolNotFoundError,
  ToolAlreadyExistsError,
  ToolValidationError,
  ToolExecutionError,

  // Context errors
  ContextNotFoundError,
  ContextStorageError,

  // Provider errors
  ProviderNotFoundError,
  ProviderRegistrationError,
  ProviderModelError,

  // Hook errors
  HookExecutionError,
} from 'fred/effect';

// Create errors with context
const error = new AgentNotFoundError({ id: 'my-agent' });
console.log(error._tag); // 'AgentNotFoundError'
console.log(error.id);   // 'my-agent'
```

### StreamResult

The new `StreamResult` object provides multiple ways to consume streaming responses:

```typescript
const result = fred.streamMessage('Hello');

// Property: textStream - yields only text content
for await (const text of result.textStream) {
  process.stdout.write(text);
}

// Property: fullStream - yields all StreamEvent objects
for await (const event of result.fullStream) {
  switch (event.type) {
    case 'token':
      process.stdout.write(event.delta);
      break;
    case 'tool-call':
      console.log('Tool:', event.toolName);
      break;
    case 'usage':
      console.log('Tokens:', event.usage.totalTokens);
      break;
  }
}

// Promise accessors (consume stream internally)
const finalText = await result.text;
const tokenUsage = await result.usage;
const stepCount = await result.steps;
const tools = await result.toolCalls;

// Callbacks (set before iteration)
result.onChunk = (event) => {
  console.log('Event:', event.type);
};
result.onFinish = ({ text, usage, steps }) => {
  console.log(`Complete: ${text.length} chars, ${usage.totalTokens} tokens`);
};
result.onError = (error) => {
  console.error('Stream error:', error);
};
```

#### StreamResult API Reference

| Property/Method | Type | Description |
|-----------------|------|-------------|
| `status` | `'streaming' \| 'complete' \| 'error'` | Current stream status (synchronous) |
| `error` | `Error \| null` | Stored error if status is 'error', null otherwise |
| `textStream` | `AsyncIterable<string>` | Yields only text content |
| `fullStream` | `AsyncIterable<StreamEvent>` | Yields all stream events |
| `text` | `Promise<string>` | Resolves to full aggregated text |
| `usage` | `Promise<TokenUsage>` | Resolves to token usage stats |
| `steps` | `Promise<number>` | Resolves to number of steps executed |
| `toolCalls` | `Promise<ToolCallInfo[]>` | Resolves to array of tool calls with results |
| `toArray()` | `Promise<StreamEvent[]>` | Collect all events into an array |
| `toText()` | `Promise<string>` | Alias for `text` getter |
| `onEvent(cb)` | `Promise<void>` | Execute callback for each event |
| `onChunk` | `((event: StreamEvent) => void)?` | Callback for each event |
| `onFinish` | `((result) => void)?` | Callback when stream completes |
| `onError` | `((error: Error) => void)?` | Callback on stream error |
| `[Symbol.asyncIterator]` | `AsyncIterator<StreamEvent>` | Enables direct `for await` iteration |

#### Checking Stream Status

```typescript
const result = fred.streamMessage('Hello');

// Status before consumption
console.log(result.status); // 'streaming'
console.log(result.error);  // null

// Consume the stream
for await (const text of result.textStream) {
  console.log(result.status); // still 'streaming' during iteration
  process.stdout.write(text);
}

// Status after successful completion
console.log(result.status); // 'complete'
console.log(result.error);  // null
```

#### Collecting Tool Calls

```typescript
const result = fred.streamMessage('Calculate 2+2');

// Wait for stream to complete and get tool calls
const toolCalls = await result.toolCalls;

for (const call of toolCalls) {
  console.log(`Tool: ${call.toolId}`);
  console.log(`Args: ${JSON.stringify(call.args)}`);
  console.log(`Result: ${call.result}`);
}
```

#### Using onEvent for Event Processing

```typescript
const result = fred.streamMessage('Hello');

// Process events with async callback
await result.onEvent(async (event) => {
  if (event.type === 'token') {
    await logToDatabase(event.delta);
  }
});

// onEvent replays cached events if stream already consumed
const events = await result.toArray();
await result.onEvent((event) => {
  // This replays from cache
  console.log(event.type);
});
```

#### Backward Compatibility with Symbol.asyncIterator

StreamResult implements `Symbol.asyncIterator`, allowing direct iteration without accessing `.fullStream`:

```typescript
const result = fred.streamMessage('Hello');

// Both patterns work identically:

// Pattern 1: Direct iteration (backward compatible)
for await (const event of result) {
  console.log(event.type);
}

// Pattern 2: Explicit fullStream access
for await (const event of result.fullStream) {
  console.log(event.type);
}
```

This ensures existing code that iterates directly over the stream result continues to work.

### FredService (Effect Users)

Aggregate service for convenient access to all Fred services:

```typescript
import { Effect } from 'effect';
import { FredService, FredServiceLive } from 'fred/effect';

const program = Effect.gen(function* () {
  const fred = yield* FredService;

  // Access all services through one object
  const agents = yield* fred.agents.getAllAgents();
  const pipelines = yield* fred.pipelines.getAllPipelines();
  const context = yield* fred.context.getContext('conv-123');

  return { agents, pipelines, context };
});

await Effect.runPromise(program.pipe(Effect.provide(FredServiceLive)));
```

### Custom Service Layers

Replace default service implementations for testing or customization:

```typescript
import { Layer, Effect } from 'effect';
import { FredLayers, AgentService, withCustomLayer } from 'fred/effect';

// Create custom agent service
const myAgentLayer = Layer.succeed(AgentService, {
  createAgent: (config) => /* custom implementation */,
  getAgent: (id) => /* custom implementation */,
  getAllAgents: () => /* custom implementation */,
  removeAgent: (id) => /* custom implementation */,
  hasAgent: (id) => /* custom implementation */,
});

// Merge with Fred layers
const customLayers = withCustomLayer(myAgentLayer);

// Use in your program
const result = await Effect.runPromise(
  myProgram.pipe(Effect.provide(customLayers))
);
```

### Runtime Access (Power Users)

Access the Effect runtime directly for advanced use cases:

```typescript
import { Runtime, Effect } from 'effect';
import { ToolRegistryService } from 'fred';

const fred = await Fred.create();
const runtime = await fred.getRuntime();

const toolCount = await Runtime.runPromise(runtime)(
  Effect.gen(function* () {
    const tools = yield* ToolRegistryService;
    return yield* tools.size();
  })
);
```

### Graceful Shutdown

New `shutdown()` method for proper resource cleanup:

```typescript
const fred = await Fred.create();

// ... use fred ...

// Cleanup when done
await fred.shutdown();
```

## API Changes Summary

### Promise API (Default Import)

| Method | v0.1.x | v0.2.5 | Notes |
|--------|--------|--------|-------|
| `new Fred()` | Sync | Sync (lazy) | Use `Fred.create()` for eager init |
| `Fred.create()` | N/A | Async | Recommended for new code |
| `streamMessage()` | `AsyncIterable<StreamEvent>` | `StreamResult` | Rich result object |
| Error handling | Plain Error | Error with cause | `error.cause` has tagged error |
| `shutdown()` | N/A | `Promise<void>` | Cleanup resources |
| `getRuntime()` | N/A | `Promise<FredRuntime>` | Access Effect runtime |

### Effect API (fred/effect)

| Export | Description |
|--------|-------------|
| `FredLayers` | Composed layer with all services |
| `AgentService` | Agent management service |
| `PipelineService` | Pipeline orchestration service |
| `ContextStorageService` | Conversation storage service |
| `ToolRegistryService` | Tool management service |
| `ProviderRegistryService` | Provider management service |
| `HookManagerService` | Hook execution service |
| `CheckpointService` | Checkpoint persistence service |
| `PauseService` | Pause/resume service |
| `FredService` | Aggregate service |
| `*Error` | Tagged error types |
| `createFredRuntime` | Runtime factory |
| `withCustomLayer` | Layer composition utility |
| `Effect, Layer, Context` | Re-exported from effect |

## Deprecation Notices

The following patterns are deprecated and may emit console warnings in development:

1. **Synchronous Fred construction for long-running apps:**

   ```typescript
   // Deprecated (works but may warn in development)
   const fred = new Fred();

   // Recommended
   const fred = await Fred.create();
   ```

## Common Migration Patterns

### Pattern 1: Initialization

```typescript
// Before
async function init() {
  const fred = new Fred();
  await fred.registerDefaultProviders();
  return fred;
}

// After
async function init() {
  const fred = await Fred.create();
  await fred.registerDefaultProviders();
  return fred;
}
```

### Pattern 2: Error Handling

```typescript
// Before
try {
  const result = await fred.processMessage('hi');
} catch (e) {
  console.error('Error:', e.message);
}

// After - access typed error details
try {
  const result = await fred.processMessage('hi');
} catch (e) {
  const cause = e.cause;
  if (cause?._tag === 'AgentNotFoundError') {
    console.error(`Agent ${cause.id} not found`);
  } else if (cause?._tag === 'PipelineExecutionError') {
    console.error(`Pipeline ${cause.pipelineId} failed at step ${cause.step}`);
  } else {
    console.error('Unknown error:', e.message);
  }
}
```

### Pattern 3: Streaming

```typescript
// Before
async function handleStream(fred, message) {
  const stream = fred.streamMessage(message);
  let text = '';
  for await (const event of stream) {
    if (event.type === 'text') {
      text += event.text;
      process.stdout.write(event.text);
    }
  }
  return text;
}

// After - use StreamResult
async function handleStream(fred, message) {
  const result = fred.streamMessage(message);

  // Streaming with callback
  result.onFinish = ({ text, usage }) => {
    console.log(`\nTokens used: ${usage.totalTokens}`);
  };

  for await (const text of result.textStream) {
    process.stdout.write(text);
  }

  // Or just await the final text
  return await result.text;
}
```

### Pattern 4: Effect Migration

```typescript
// Before - Promise-based with error wrapping
const fred = await Fred.create();
try {
  const agent = fred.getAgent('my-agent');
} catch (e) {
  if (e.cause?._tag === 'AgentNotFoundError') {
    // Handle
  }
}

// After - Full Effect composition
import { Effect } from 'effect';
import { FredLayers, AgentService } from 'fred/effect';

const program = Effect.gen(function* () {
  const agents = yield* AgentService;
  const agent = yield* agents.getAgent('my-agent');
  return agent;
}).pipe(
  Effect.catchTag('AgentNotFoundError', (e) =>
    Effect.succeed(createDefaultAgent())
  )
);

await Effect.runPromise(program.pipe(Effect.provide(FredLayers)));
```

## FAQ

### Do I need to change my code?

If you're using the Promise API (default import from 'fred'), your code should continue to work. However, we recommend:

1. Using `Fred.create()` instead of `new Fred()`
2. Updating streaming code to use the new `StreamResult` patterns
3. Handling typed errors via `error.cause`
4. Adding `fred.shutdown()` to your cleanup code

### When should I use the Effect API?

Use `fred/effect` when you want:

- Full Effect composition in your application
- Type-safe error handling with `catchTag`
- Custom service implementations via layers
- Integration with other Effect libraries
- Fine-grained control over resource lifecycle

### Is this a breaking change?

Mostly backwards compatible. The main change is that `streamMessage()` now returns a `StreamResult` instead of a raw `AsyncIterable`. However, `StreamResult` implements `Symbol.asyncIterator`, so existing code that uses `for await (const event of result)` continues to work without changes. For explicit control, use `result.fullStream` or `result.textStream`.

### What if I'm already using Effect?

Great! Import from `fred/effect` to get full Effect integration:

```typescript
import {
  FredLayers,
  AgentService,
  PipelineService,
  AgentNotFoundError,
  Effect,
  Layer,
} from 'fred/effect';
```

The Effect re-exports (`Effect`, `Layer`, `Context`, etc.) are for convenience. You can also import Effect separately:

```typescript
import { Effect, Layer } from 'effect';
import { FredLayers, AgentService } from 'fred/effect';
```

### How do I test with custom services?

Use `withCustomLayer` to inject mock services:

```typescript
import { Layer } from 'effect';
import { AgentService, withCustomLayer } from 'fred/effect';

const mockAgentLayer = Layer.succeed(AgentService, {
  getAgent: () => Effect.succeed(mockAgent),
  getAllAgents: () => Effect.succeed([mockAgent]),
  // ...
});

const testLayers = withCustomLayer(mockAgentLayer);

await Effect.runPromise(
  testProgram.pipe(Effect.provide(testLayers))
);
```

## Getting Help

- [GitHub Issues](https://github.com/your-org/fred/issues)
- [Documentation](https://fred.dev/docs)
- [API Reference](https://fred.dev/docs/api-reference)
