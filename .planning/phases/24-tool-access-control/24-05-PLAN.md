---
phase: 24-tool-access-control
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/hooks/types.ts
  - packages/core/src/tool-gate/service.ts
  - packages/core/src/tool-gate/types.ts
  - tests/unit/core/tool-gate/service.test.ts
autonomous: true

must_haves:
  truths:
    - "Every policy decision emits an observable hook event with outcome, tool ID, intent, agent, role, matched rule, timestamp, and correlation IDs"
    - "Tool arguments in audit payloads are hashed by default to prevent sensitive data leakage"
    - "Audit events use structured JSON format compatible with Phase 22 observability infrastructure"
  artifacts:
    - path: "packages/core/src/hooks/types.ts"
      provides: "Policy decision hook type in HookType union"
      contains: "afterPolicyDecision"
    - path: "packages/core/src/tool-gate/service.ts"
      provides: "Hook emission from evaluateTool and filterTools"
    - path: "packages/core/src/tool-gate/types.ts"
      provides: "PolicyAuditEvent interface for structured audit payloads"
    - path: "tests/unit/core/tool-gate/service.test.ts"
      provides: "Tests proving audit event emission with hashed args and correlation metadata"
  key_links:
    - from: "packages/core/src/tool-gate/service.ts"
      to: "packages/core/src/hooks/service.ts"
      via: "HookManagerService executeHooks call with afterPolicyDecision type"
      pattern: "afterPolicyDecision"
    - from: "packages/core/src/tool-gate/service.ts"
      to: "packages/core/src/observability/service.ts"
      via: "hashPayload for argument hashing"
      pattern: "hashPayload"
---

<objective>
Emit structured audit hook events from ToolGateService for every policy decision so all allow/deny/requireApproval outcomes are observable via the Phase 22 observability infrastructure.

Purpose: Satisfy GATE-05 (all policy decisions logged via observability hooks for audit trails). This completes the audit trail requirement by making every gate evaluation visible to hook consumers with full context metadata and hashed arguments.
Output: Policy audit events flowing through HookManagerService with structured metadata, verified by deterministic tests.
</objective>

<execution_context>
@/home/gimbo/.claude/get-shit-done/workflows/execute-plan.md
@/home/gimbo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-tool-access-control/24-CONTEXT.md

@packages/core/src/tool-gate/service.ts
@packages/core/src/tool-gate/types.ts
@packages/core/src/hooks/types.ts
@packages/core/src/hooks/service.ts
@packages/core/src/observability/service.ts
@tests/unit/core/tool-gate/service.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add policy audit event types and emit from ToolGateService</name>
  <files>
packages/core/src/hooks/types.ts
packages/core/src/tool-gate/types.ts
packages/core/src/tool-gate/service.ts
  </files>
  <action>
1. In `packages/core/src/hooks/types.ts`, add `'afterPolicyDecision'` to the `HookType` union. Place it after the existing tool execution hooks (`afterToolCalled`). This is the single hook type for ALL policy decision audit events.

2. In `packages/core/src/tool-gate/types.ts`, add a `PolicyAuditEvent` interface:
```typescript
export interface PolicyAuditEvent {
  toolId: string;
  outcome: 'allow' | 'deny' | 'requireApproval';
  intentId?: string;
  agentId?: string;
  userId?: string;
  role?: string;
  matchedRules: ToolGateRuleEvaluation[];
  deniedBy?: ToolGateRuleEvaluation;
  argsHash?: string;
  timestamp: string;
}
```

3. Modify `ToolGateServiceImpl` in `packages/core/src/tool-gate/service.ts`:
   - Add an optional `HookManagerService` dependency (use Effect.serviceOption pattern like HookManagerServiceLive does with ObservabilityService).
   - Add an optional `ObservabilityService` dependency for `hashPayload`.
   - After computing the decision in `evaluateTool()`, emit a hook event:
     - Type: `'afterPolicyDecision'`
     - Data: a `PolicyAuditEvent` with outcome derived from decision (if denied -> 'deny', if requireApproval -> 'requireApproval', else 'allow')
     - Include context fields (intentId, agentId, userId, role) from the ToolGateContext
     - Include matchedRules and deniedBy from the decision
     - Include ISO 8601 timestamp
     - Hash tool arguments using ObservabilityService.hashPayload if available; if ObservabilityService not provided, omit argsHash
   - Use `Effect.catchAll` around the hook emission so it never fails the gate decision itself (audit is best-effort, gate evaluation must not break)
   - Do NOT emit hooks from `filterTools` individually -- `filterTools` calls `evaluateTool` per tool which will emit.

4. Update `ToolGateServiceLive` Layer to optionally resolve `HookManagerService` and `ObservabilityService` via `Effect.serviceOption`. Pass them into the constructor. This keeps the service backward-compatible (works without hooks/observability).

IMPORTANT: Do NOT modify the existing `evaluateTool` return value or API contract. Hook emission is a side-effect only. The function signature and return type remain identical.
  </action>
  <verify>bun test tests/unit/core/tool-gate/service.test.ts</verify>
  <done>ToolGateService emits afterPolicyDecision hooks with structured PolicyAuditEvent data including hashed args, and existing tests still pass (backward compatible).</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for policy audit event emission</name>
  <files>
tests/unit/core/tool-gate/service.test.ts
  </files>
  <action>
Add a new `describe('policy audit events', ...)` block in the existing test file. Tests need a mock HookManagerService to capture emitted events.

1. Create a `mockHookManager` factory that returns a `HookManagerService` implementation backed by an array collector. The `executeHooks` method should push received events into the array and return `Effect.succeed([])`. All other methods can be no-ops. Wire this into the test layer using `Layer.succeed(HookManagerService, mockHookManager)`.

2. Create a `mockObservabilityService` that implements `hashPayload` as a simple deterministic hash (e.g., `sha256(JSON.stringify(payload)).slice(0, 16)`). Wire via `Layer.succeed(ObservabilityService, mockObservability)`.

3. Build a test layer: `ToolGateServiceLive.pipe(Layer.provide(Layer.merge(ToolRegistryServiceLive, Layer.merge(hookLayer, obsLayer))))`.

4. Tests to write:
   a. "emits afterPolicyDecision with allow outcome" - set policies with allow, evaluate tool, verify hook event has outcome='allow', correct toolId, intentId, agentId
   b. "emits afterPolicyDecision with deny outcome" - set deny policy, evaluate, verify outcome='deny' and deniedBy present
   c. "emits afterPolicyDecision with requireApproval outcome" - set requireApproval policy, evaluate, verify outcome='requireApproval'
   d. "includes hashed arguments in audit event" - pass args context, verify argsHash is a non-empty hex string (not raw args)
   e. "includes matched rules in audit event" - verify matchedRules array contains expected scope/source/effect
   f. "includes timestamp in audit event" - verify timestamp is valid ISO 8601
   g. "audit emission failure does not break gate decision" - provide a hook manager that throws, verify evaluateTool still returns correct decision
   h. "filterTools emits one audit event per tool" - filter 3 tools, verify 3 hook events captured

Use the existing test patterns (runWithToolGate helper, testTool factory). Adapt the helper to support the new layer composition with hooks.
  </action>
  <verify>bun test tests/unit/core/tool-gate/service.test.ts</verify>
  <done>8+ new tests pass covering audit event emission for allow/deny/requireApproval outcomes with hashed args, correlation metadata, and fault tolerance.</done>
</task>

</tasks>

<verification>
- `bun test tests/unit/core/tool-gate/service.test.ts` passes (both existing 7 tests and new audit tests)
- Hook events contain: outcome, toolId, intentId, agentId, userId, role, matchedRules, timestamp, argsHash
- Arguments are never stored in raw form -- only hashed
- Gate decisions are not affected by hook emission failures
</verification>

<success_criteria>
- Every ToolGateService.evaluateTool call emits an afterPolicyDecision hook event
- Audit payloads include all required context fields per GATE-05
- Tool arguments are hashed by default per user decision
- Backward compatibility maintained (service works without HookManagerService)
</success_criteria>

<output>
After completion, create `.planning/phases/24-tool-access-control/24-05-SUMMARY.md`
</output>
