---
phase: 24-tool-access-control
plan: 06
type: execute
wave: 2
depends_on:
  - 24-05
files_modified:
  - packages/core/src/tool-gate/service.ts
  - packages/core/src/tool-gate/types.ts
  - packages/core/src/agent/factory.ts
  - tests/unit/core/tool-gate/service.test.ts
  - tests/unit/core/agent/factory.test.ts
autonomous: true

must_haves:
  truths:
    - "Tools listed in requireApproval policies trigger a HITL pause request with tool name, intent classification, and requesting agent context"
    - "Approval timeout defaults to deny for security (auto-deny after timeout)"
    - "Approval is session-scoped and does not carry over to other conversations"
    - "Approval and denial outcomes are emitted as observable hook events for audit"
  artifacts:
    - path: "packages/core/src/tool-gate/types.ts"
      provides: "ApprovalRequest interface with tool/intent/agent context and session scope"
    - path: "packages/core/src/tool-gate/service.ts"
      provides: "Session-scoped approval tracking and approval request generation"
    - path: "packages/core/src/agent/factory.ts"
      provides: "Integration point where requireApproval decisions trigger pause signals"
    - path: "tests/unit/core/tool-gate/service.test.ts"
      provides: "Tests for approval request generation, session scoping, and timeout deny"
    - path: "tests/unit/core/agent/factory.test.ts"
      provides: "Tests for requireApproval triggering pause signal in agent execution"
  key_links:
    - from: "packages/core/src/tool-gate/service.ts"
      to: "packages/core/src/pipeline/pause/types.ts"
      via: "PauseSignal generation for requireApproval decisions"
      pattern: "__pause.*true"
    - from: "packages/core/src/agent/factory.ts"
      to: "packages/core/src/tool-gate/service.ts"
      via: "evaluateTool check for requireApproval before tool execution"
      pattern: "requireApproval"
---

<objective>
Implement HITL approval workflow for tools with requireApproval policies so sensitive tool calls pause execution for human approval with deny-on-timeout semantics and session-scoped persistence.

Purpose: Satisfy GATE-04 (sensitive tool calls trigger HITL pause for human approval). This connects the requireApproval policy decision to the existing pause/resume infrastructure from Phase 10, with security-first defaults.
Output: Working approval workflow where requireApproval policies generate pause signals, approvals are tracked per session, and all outcomes are audited.
</objective>

<execution_context>
@/home/gimbo/.claude/get-shit-done/workflows/execute-plan.md
@/home/gimbo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-tool-access-control/24-CONTEXT.md
@.planning/phases/24-tool-access-control/24-05-SUMMARY.md

@packages/core/src/tool-gate/service.ts
@packages/core/src/tool-gate/types.ts
@packages/core/src/agent/factory.ts
@packages/core/src/pipeline/pause/types.ts
@packages/core/src/pipeline/pause/tool.ts
@tests/unit/core/tool-gate/service.test.ts
@tests/unit/core/agent/factory.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add approval request types and session-scoped tracking to ToolGateService</name>
  <files>
packages/core/src/tool-gate/types.ts
packages/core/src/tool-gate/service.ts
  </files>
  <action>
1. In `packages/core/src/tool-gate/types.ts`, add:

```typescript
export interface ToolApprovalRequest {
  toolId: string;
  intentId?: string;
  agentId?: string;
  userId?: string;
  reason: string;
  /** Session key for scoping approval persistence */
  sessionKey: string;
}

export interface ToolApprovalRecord {
  toolId: string;
  sessionKey: string;
  approved: boolean;
  timestamp: string;
}
```

Add to `ToolGateServiceApi`:
```typescript
/** Check if tool has a session-scoped approval already */
hasApproval(toolId: string, sessionKey: string): Effect.Effect<boolean>;

/** Record an approval or denial for a tool in a session */
recordApproval(toolId: string, sessionKey: string, approved: boolean): Effect.Effect<void>;

/** Clear all approvals (e.g., when session ends) */
clearApprovals(sessionKey?: string): Effect.Effect<void>;

/** Generate an approval request for a requireApproval decision */
createApprovalRequest(decision: ToolGateDecision, context: ToolGateContext): Effect.Effect<ToolApprovalRequest | undefined>;
```

2. In `packages/core/src/tool-gate/service.ts`, implement:
   - Add a `Ref<Map<string, ToolApprovalRecord>>` to `ToolGateServiceImpl` for session-scoped approval tracking. The map key is `${sessionKey}:${toolId}`.
   - `hasApproval`: Look up the key in the approval map. Return true only if found and `approved === true`.
   - `recordApproval`: Store a ToolApprovalRecord with current timestamp. Emit an `afterPolicyDecision` hook event with outcome='allow' (if approved) or outcome='deny' (if denied) and metadata indicating this is an approval response.
   - `clearApprovals`: If sessionKey provided, remove all entries matching that session. Otherwise clear all.
   - `createApprovalRequest`: If `decision.requireApproval` is true and no existing approval exists for this tool+session, return a `ToolApprovalRequest` with context. If already approved in session, return undefined (skip re-prompting). Session key is derived from `context.metadata?.conversationId ?? context.userId ?? 'default'` -- per user decision, approval is session-scoped (current conversation only).

IMPORTANT per user decision: HITL trigger is ONLY from explicit `requireApproval` policy flag. Do NOT automatically trigger for destructive/admin capability tags. The policy author must explicitly list tools in `requireApproval` array.

Deny-on-timeout: The approval request itself does not implement timeout -- the existing pause infrastructure handles TTL. But when generating the approval request, include a `ttlMs` field (default 300000 = 5 minutes) in the request metadata. The consumer (agent factory) will pass this to the pause signal.
  </action>
  <verify>bun test tests/unit/core/tool-gate/service.test.ts</verify>
  <done>ToolGateService supports session-scoped approval tracking with hasApproval/recordApproval/clearApprovals/createApprovalRequest APIs. Existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Wire requireApproval into agent factory pause flow and add tests</name>
  <files>
packages/core/src/agent/factory.ts
tests/unit/core/tool-gate/service.test.ts
tests/unit/core/agent/factory.test.ts
  </files>
  <action>
1. In `packages/core/src/agent/factory.ts`, modify the tool execution path:
   - After the existing tool gate filtering (around line 618-631), for tools that were ALLOWED but have `requireApproval: true` in their decision:
     - Check `toolGateService.hasApproval(toolId, sessionKey)` where sessionKey comes from `policyContext.conversationId ?? policyContext.userId ?? 'default'`.
     - If not yet approved, call `toolGateService.createApprovalRequest(decision, gateContext)`.
     - If an approval request is generated, create a PauseSignal: `{ __pause: true, prompt: "Tool '{toolId}' requires approval. Intent: {intentId}, Agent: {agentId}.", metadata: { toolId, intentId, agentId, approvalRequest: true }, ttlMs: 300000 }`.
     - Return the pause signal as the tool result (the existing pause detection infrastructure in the executor will handle checkpointing).
     - If already approved in session, allow the tool call to proceed normally.
   - This integrates with the existing `POLICY_DENIED` fallback: if a tool is both denied and somehow called, POLICY_DENIED handles it. requireApproval is a separate path for tools that are conditionally allowed.

2. In `tests/unit/core/tool-gate/service.test.ts`, add a `describe('approval workflow', ...)` block:
   a. "createApprovalRequest returns request for requireApproval decision" - create decision with requireApproval=true, verify request contains toolId, sessionKey, context fields
   b. "createApprovalRequest returns undefined for already-approved tool" - recordApproval(true), then createApprovalRequest, verify returns undefined
   c. "hasApproval returns false for unapproved tool" - verify false before any recordApproval
   d. "hasApproval returns true after recordApproval(true)" - record approval, verify true
   e. "hasApproval returns false after recordApproval(false)" - record denial, verify false (denial is also recorded)
   f. "clearApprovals removes session-scoped approvals" - record approval, clearApprovals with sessionKey, verify hasApproval returns false
   g. "clearApprovals without sessionKey clears all" - record approvals for multiple sessions, clearApprovals(), verify all gone
   h. "approval does not carry across sessions" - record approval for session A, verify hasApproval returns false for session B

3. In `tests/unit/core/agent/factory.test.ts`, add a test:
   a. "requireApproval tool generates pause signal" - configure a tool with requireApproval policy, invoke agent, verify the result contains a pause signal with approval metadata. This may require mocking the appropriate service layer.
  </action>
  <verify>bun test tests/unit/core/tool-gate/service.test.ts && bun test tests/unit/core/agent/factory.test.ts</verify>
  <done>requireApproval policies trigger pause signals with tool/intent/agent context, approvals are session-scoped, timeout defaults to deny, and all paths are tested.</done>
</task>

</tasks>

<verification>
- `bun test tests/unit/core/tool-gate/service.test.ts` passes (existing + audit + approval tests)
- `bun test tests/unit/core/agent/factory.test.ts` passes (existing + approval pause test)
- requireApproval generates PauseSignal with correct metadata
- Approvals are session-scoped (conversation-only per user decision)
- Timeout defaults to deny (TTL included in pause signal)
- HITL only triggers from explicit requireApproval policy, NOT from capability tags
</verification>

<success_criteria>
- Tools in requireApproval policy lists trigger HITL pause with tool+intent+agent context
- Previously-approved tools in same session skip re-prompting
- Timeout auto-denies (security-first per user decision)
- No cross-conversation approval leakage
- Approval/denial outcomes are audited via afterPolicyDecision hook events
</success_criteria>

<output>
After completion, create `.planning/phases/24-tool-access-control/24-06-SUMMARY.md`
</output>
